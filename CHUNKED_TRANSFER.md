# 大文件分块传输机制

## 🎯 设计目标

解决大图片传输失败的问题，采用**请求-响应**的分块传输机制，确保可靠性和进度可控。

## 📊 技术方案

### 传输流程

```
插件端 → 服务器：发送完整图片数据
         ↓
      服务器切分为多个分块（100KB/块）
         ↓
      服务器广播：image-transfer-start（通知开始传输）
         ↓
手机端 → 服务器：request-next-chunk（请求第 0 块）
         ↓
      服务器 → 手机端：image-chunk（发送第 0 块）
         ↓
手机端接收并存储第 0 块
         ↓
手机端 → 服务器：phone-progress-update（上报进度）
         ↓
      服务器 → 插件端：sender-progress-update（转发进度）
         ↓
手机端 → 服务器：request-next-chunk（请求第 1 块）
         ↓
      ... 重复直到最后一块 ...
         ↓
手机端组合所有分块，显示图片
         ↓
手机端 → 服务器：phone-received-image（通知完成）
         ↓
      服务器 → 插件端：image-received-by-phone（转发完成）
```

## 🔧 关键特性

### 1. 逐块确认传输
- **按需拉取**：接收端请求一块，服务器发送一块
- **避免拥堵**：不会一次性发送所有分块
- **可靠性高**：每块都有确认，不会丢失

### 2. 实时进度反馈
- 手机端每接收一块，立即上报进度
- 服务器转发进度给插件端
- 双端同步显示进度条

### 3. 智能分块策略
- **小图片（< 100KB）**：直接传输，无需分块
- **大图片（≥ 100KB）**：分块传输，每块 100KB
- 块大小可调整，平衡速度和可靠性

### 4. 错误处理
- 传输超时检测
- 无效分块索引检查
- 房间不存在检查
- 错误信息反馈到接收端

## 📝 事件说明

### 服务器端事件

| 事件名 | 方向 | 参数 | 说明 |
|--------|------|------|------|
| `send-image-to-phone` | 接收 | `{roomId, imageData}` | 插件端发送图片 |
| `request-next-chunk` | 接收 | `{roomId, chunkIndex}` | 手机端请求分块 |
| `phone-progress-update` | 接收 | `{roomId, progress, chunkIndex, totalChunks}` | 手机端上报进度 |
| `phone-received-image` | 接收 | `roomId` | 手机端确认接收 |
| `image-transfer-start` | 发送 | `{totalChunks, totalSize, chunkSize}` | 通知开始传输 |
| `image-chunk` | 发送 | `{chunkIndex, totalChunks, chunk, isLastChunk}` | 发送分块数据 |
| `sender-progress-update` | 发送 | `{progress, chunkIndex, totalChunks}` | 转发进度给插件 |
| `image-received-by-phone` | 发送 | 无 | 通知插件传输完成 |
| `transfer-error` | 发送 | `{message}` | 传输错误 |

## 🔍 调试日志

### 正常流程日志示例

**服务器端：**
```
发送图片到手机，房间: IMG_ABC123，图片大小: 1321 KB
图片较大，使用分块传输，总大小: 1321KB
图片已切分为 14 块，等待接收端请求
收到分块请求，房间: IMG_ABC123, 块索引: 0
发送分块 1/14 到接收端，大小: 98 KB
收到分块请求，房间: IMG_ABC123, 块索引: 1
发送分块 2/14 到接收端，大小: 98 KB
...
手机端进度更新，房间: IMG_ABC123, 进度: 100%
手机端确认收到图片，房间: IMG_ABC123
```

**手机端：**
```
开始接收图片，总块数: 14 总大小: 1321 KB
请求第一个分块
收到分块: 1 / 14 大小: 98 KB
请求下一个分块: 1
收到分块: 2 / 14 大小: 98 KB
...
接收完成，组合图片数据
组合后的图片大小: 1321 KB
```

**插件端：**
```
Image Sender: 开始传输，总块数: 14 总大小: 1321 KB
Image Sender: 接收端进度: 7%
Image Sender: 接收端进度: 14%
...
Image Sender: 接收端进度: 100%
Image Sender: 手机已收到图片
Image Sender: 传输完成，断开连接
```

## ⚙️ 配置参数

### 服务器端（server.js）
```javascript
const CHUNK_SIZE = 100000; // 每块 100KB
```

### 手机端（receive.html）
```javascript
setTimeout(() => {
  socket.emit('request-next-chunk', ...);
}, 10); // 10ms 延迟，避免请求过快
```

## 🚀 性能优化

1. **块大小优化**：100KB 是速度和可靠性的平衡点
2. **请求延迟**：10ms 延迟避免服务器过载
3. **预分配数组**：`new Array(totalChunks)` 避免动态扩容
4. **及时断开**：传输完成后 2 秒断开连接，释放资源

## 📊 测试建议

测试用例：
1. ✅ 小图片（< 100KB）：直接传输
2. ✅ 中等图片（100KB - 1MB）：分块传输，快速完成
3. ✅ 大图片（1MB - 5MB）：分块传输，进度条平滑
4. ✅ 超大图片（> 5MB）：分块传输，考虑内存占用

## 🐛 常见问题

### Q: 为什么改用请求-响应模式？
A: 之前的推送模式（服务器循环发送所有分块）会导致：
- 网络拥堵
- 消息丢失
- 进度不可控

### Q: 10ms 延迟会不会影响速度？
A: 不会。10ms 延迟主要是避免请求过快导致服务器压力，实际传输速度主要受网络带宽限制。

### Q: 如果中途断网会怎样？
A: Socket.IO 会自动断开连接，用户需要重新扫码传输。未来可以考虑添加断点续传功能。

## 📈 未来优化方向

1. **断点续传**：记录已接收的分块，断线重连后继续
2. **并行传输**：同时请求多个分块，提高速度
3. **动态块大小**：根据网络状况自动调整块大小
4. **压缩传输**：在服务器端压缩数据，减少传输量

